// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/myServer.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_protos_2fmyServer_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_protos_2fmyServer_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_protos_2fmyServer_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_protos_2fmyServer_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_protos_2fmyServer_2eproto;
namespace myserver {
class ConnectReply;
struct ConnectReplyDefaultTypeInternal;
extern ConnectReplyDefaultTypeInternal _ConnectReply_default_instance_;
class ConnectRequest;
struct ConnectRequestDefaultTypeInternal;
extern ConnectRequestDefaultTypeInternal _ConnectRequest_default_instance_;
class DisconnectReply;
struct DisconnectReplyDefaultTypeInternal;
extern DisconnectReplyDefaultTypeInternal _DisconnectReply_default_instance_;
class DisconnectRequest;
struct DisconnectRequestDefaultTypeInternal;
extern DisconnectRequestDefaultTypeInternal _DisconnectRequest_default_instance_;
class PublishReply;
struct PublishReplyDefaultTypeInternal;
extern PublishReplyDefaultTypeInternal _PublishReply_default_instance_;
class PublishRequest;
struct PublishRequestDefaultTypeInternal;
extern PublishRequestDefaultTypeInternal _PublishRequest_default_instance_;
class ShowBrokersReply;
struct ShowBrokersReplyDefaultTypeInternal;
extern ShowBrokersReplyDefaultTypeInternal _ShowBrokersReply_default_instance_;
class ShowBrokersRequest;
struct ShowBrokersRequestDefaultTypeInternal;
extern ShowBrokersRequestDefaultTypeInternal _ShowBrokersRequest_default_instance_;
class ShowClientsReply;
struct ShowClientsReplyDefaultTypeInternal;
extern ShowClientsReplyDefaultTypeInternal _ShowClientsReply_default_instance_;
class ShowClientsRequest;
struct ShowClientsRequestDefaultTypeInternal;
extern ShowClientsRequestDefaultTypeInternal _ShowClientsRequest_default_instance_;
class SubscribeReply;
struct SubscribeReplyDefaultTypeInternal;
extern SubscribeReplyDefaultTypeInternal _SubscribeReply_default_instance_;
class SubscribeRequest;
struct SubscribeRequestDefaultTypeInternal;
extern SubscribeRequestDefaultTypeInternal _SubscribeRequest_default_instance_;
}  // namespace myserver
PROTOBUF_NAMESPACE_OPEN
template <>
::myserver::ConnectReply* Arena::CreateMaybeMessage<::myserver::ConnectReply>(Arena*);
template <>
::myserver::ConnectRequest* Arena::CreateMaybeMessage<::myserver::ConnectRequest>(Arena*);
template <>
::myserver::DisconnectReply* Arena::CreateMaybeMessage<::myserver::DisconnectReply>(Arena*);
template <>
::myserver::DisconnectRequest* Arena::CreateMaybeMessage<::myserver::DisconnectRequest>(Arena*);
template <>
::myserver::PublishReply* Arena::CreateMaybeMessage<::myserver::PublishReply>(Arena*);
template <>
::myserver::PublishRequest* Arena::CreateMaybeMessage<::myserver::PublishRequest>(Arena*);
template <>
::myserver::ShowBrokersReply* Arena::CreateMaybeMessage<::myserver::ShowBrokersReply>(Arena*);
template <>
::myserver::ShowBrokersRequest* Arena::CreateMaybeMessage<::myserver::ShowBrokersRequest>(Arena*);
template <>
::myserver::ShowClientsReply* Arena::CreateMaybeMessage<::myserver::ShowClientsReply>(Arena*);
template <>
::myserver::ShowClientsRequest* Arena::CreateMaybeMessage<::myserver::ShowClientsRequest>(Arena*);
template <>
::myserver::SubscribeReply* Arena::CreateMaybeMessage<::myserver::SubscribeReply>(Arena*);
template <>
::myserver::SubscribeRequest* Arena::CreateMaybeMessage<::myserver::SubscribeRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace myserver {

// ===================================================================


// -------------------------------------------------------------------

class ConnectRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:myserver.ConnectRequest) */ {
 public:
  inline ConnectRequest() : ConnectRequest(nullptr) {}
  ~ConnectRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ConnectRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectRequest(const ConnectRequest& from);
  ConnectRequest(ConnectRequest&& from) noexcept
    : ConnectRequest() {
    *this = ::std::move(from);
  }

  inline ConnectRequest& operator=(const ConnectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectRequest& operator=(ConnectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectRequest* internal_default_instance() {
    return reinterpret_cast<const ConnectRequest*>(
               &_ConnectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ConnectRequest& a, ConnectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConnectRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConnectRequest& from) {
    ConnectRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "myserver.ConnectRequest";
  }
  protected:
  explicit ConnectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdrsFieldNumber = 1,
    kClientIDFieldNumber = 2,
  };
  // string adrs = 1;
  void clear_adrs() ;
  const std::string& adrs() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_adrs(Arg_&& arg, Args_... args);
  std::string* mutable_adrs();
  PROTOBUF_NODISCARD std::string* release_adrs();
  void set_allocated_adrs(std::string* ptr);

  private:
  const std::string& _internal_adrs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_adrs(
      const std::string& value);
  std::string* _internal_mutable_adrs();

  public:
  // string clientID = 2;
  void clear_clientid() ;
  const std::string& clientid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_clientid(Arg_&& arg, Args_... args);
  std::string* mutable_clientid();
  PROTOBUF_NODISCARD std::string* release_clientid();
  void set_allocated_clientid(std::string* ptr);

  private:
  const std::string& _internal_clientid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientid(
      const std::string& value);
  std::string* _internal_mutable_clientid();

  public:
  // @@protoc_insertion_point(class_scope:myserver.ConnectRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr adrs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fmyServer_2eproto;
};// -------------------------------------------------------------------

class ConnectReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:myserver.ConnectReply) */ {
 public:
  inline ConnectReply() : ConnectReply(nullptr) {}
  ~ConnectReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ConnectReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectReply(const ConnectReply& from);
  ConnectReply(ConnectReply&& from) noexcept
    : ConnectReply() {
    *this = ::std::move(from);
  }

  inline ConnectReply& operator=(const ConnectReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectReply& operator=(ConnectReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectReply* internal_default_instance() {
    return reinterpret_cast<const ConnectReply*>(
               &_ConnectReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ConnectReply& a, ConnectReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConnectReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConnectReply& from) {
    ConnectReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "myserver.ConnectReply";
  }
  protected:
  explicit ConnectReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
  };
  // string response = 1;
  void clear_response() ;
  const std::string& response() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_response(Arg_&& arg, Args_... args);
  std::string* mutable_response();
  PROTOBUF_NODISCARD std::string* release_response();
  void set_allocated_response(std::string* ptr);

  private:
  const std::string& _internal_response() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_response(
      const std::string& value);
  std::string* _internal_mutable_response();

  public:
  // @@protoc_insertion_point(class_scope:myserver.ConnectReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fmyServer_2eproto;
};// -------------------------------------------------------------------

class DisconnectRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:myserver.DisconnectRequest) */ {
 public:
  inline DisconnectRequest() : DisconnectRequest(nullptr) {}
  ~DisconnectRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DisconnectRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DisconnectRequest(const DisconnectRequest& from);
  DisconnectRequest(DisconnectRequest&& from) noexcept
    : DisconnectRequest() {
    *this = ::std::move(from);
  }

  inline DisconnectRequest& operator=(const DisconnectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DisconnectRequest& operator=(DisconnectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DisconnectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DisconnectRequest* internal_default_instance() {
    return reinterpret_cast<const DisconnectRequest*>(
               &_DisconnectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DisconnectRequest& a, DisconnectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DisconnectRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DisconnectRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DisconnectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DisconnectRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DisconnectRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DisconnectRequest& from) {
    DisconnectRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DisconnectRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "myserver.DisconnectRequest";
  }
  protected:
  explicit DisconnectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdrsFieldNumber = 1,
    kClientIDFieldNumber = 2,
  };
  // string adrs = 1;
  void clear_adrs() ;
  const std::string& adrs() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_adrs(Arg_&& arg, Args_... args);
  std::string* mutable_adrs();
  PROTOBUF_NODISCARD std::string* release_adrs();
  void set_allocated_adrs(std::string* ptr);

  private:
  const std::string& _internal_adrs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_adrs(
      const std::string& value);
  std::string* _internal_mutable_adrs();

  public:
  // string clientID = 2;
  void clear_clientid() ;
  const std::string& clientid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_clientid(Arg_&& arg, Args_... args);
  std::string* mutable_clientid();
  PROTOBUF_NODISCARD std::string* release_clientid();
  void set_allocated_clientid(std::string* ptr);

  private:
  const std::string& _internal_clientid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientid(
      const std::string& value);
  std::string* _internal_mutable_clientid();

  public:
  // @@protoc_insertion_point(class_scope:myserver.DisconnectRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr adrs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fmyServer_2eproto;
};// -------------------------------------------------------------------

class DisconnectReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:myserver.DisconnectReply) */ {
 public:
  inline DisconnectReply() : DisconnectReply(nullptr) {}
  ~DisconnectReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DisconnectReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DisconnectReply(const DisconnectReply& from);
  DisconnectReply(DisconnectReply&& from) noexcept
    : DisconnectReply() {
    *this = ::std::move(from);
  }

  inline DisconnectReply& operator=(const DisconnectReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline DisconnectReply& operator=(DisconnectReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DisconnectReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const DisconnectReply* internal_default_instance() {
    return reinterpret_cast<const DisconnectReply*>(
               &_DisconnectReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DisconnectReply& a, DisconnectReply& b) {
    a.Swap(&b);
  }
  inline void Swap(DisconnectReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DisconnectReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DisconnectReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DisconnectReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DisconnectReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DisconnectReply& from) {
    DisconnectReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DisconnectReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "myserver.DisconnectReply";
  }
  protected:
  explicit DisconnectReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
  };
  // string response = 1;
  void clear_response() ;
  const std::string& response() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_response(Arg_&& arg, Args_... args);
  std::string* mutable_response();
  PROTOBUF_NODISCARD std::string* release_response();
  void set_allocated_response(std::string* ptr);

  private:
  const std::string& _internal_response() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_response(
      const std::string& value);
  std::string* _internal_mutable_response();

  public:
  // @@protoc_insertion_point(class_scope:myserver.DisconnectReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fmyServer_2eproto;
};// -------------------------------------------------------------------

class PublishRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:myserver.PublishRequest) */ {
 public:
  inline PublishRequest() : PublishRequest(nullptr) {}
  ~PublishRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PublishRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PublishRequest(const PublishRequest& from);
  PublishRequest(PublishRequest&& from) noexcept
    : PublishRequest() {
    *this = ::std::move(from);
  }

  inline PublishRequest& operator=(const PublishRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublishRequest& operator=(PublishRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PublishRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublishRequest* internal_default_instance() {
    return reinterpret_cast<const PublishRequest*>(
               &_PublishRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PublishRequest& a, PublishRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PublishRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublishRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PublishRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PublishRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PublishRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PublishRequest& from) {
    PublishRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PublishRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "myserver.PublishRequest";
  }
  protected:
  explicit PublishRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdrsFieldNumber = 1,
    kTopicFieldNumber = 2,
    kMessageFieldNumber = 3,
    kClientIDFieldNumber = 4,
  };
  // string adrs = 1;
  void clear_adrs() ;
  const std::string& adrs() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_adrs(Arg_&& arg, Args_... args);
  std::string* mutable_adrs();
  PROTOBUF_NODISCARD std::string* release_adrs();
  void set_allocated_adrs(std::string* ptr);

  private:
  const std::string& _internal_adrs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_adrs(
      const std::string& value);
  std::string* _internal_mutable_adrs();

  public:
  // string topic = 2;
  void clear_topic() ;
  const std::string& topic() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_topic(Arg_&& arg, Args_... args);
  std::string* mutable_topic();
  PROTOBUF_NODISCARD std::string* release_topic();
  void set_allocated_topic(std::string* ptr);

  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(
      const std::string& value);
  std::string* _internal_mutable_topic();

  public:
  // string message = 3;
  void clear_message() ;
  const std::string& message() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* ptr);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // string clientID = 4;
  void clear_clientid() ;
  const std::string& clientid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_clientid(Arg_&& arg, Args_... args);
  std::string* mutable_clientid();
  PROTOBUF_NODISCARD std::string* release_clientid();
  void set_allocated_clientid(std::string* ptr);

  private:
  const std::string& _internal_clientid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientid(
      const std::string& value);
  std::string* _internal_mutable_clientid();

  public:
  // @@protoc_insertion_point(class_scope:myserver.PublishRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr adrs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fmyServer_2eproto;
};// -------------------------------------------------------------------

class PublishReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:myserver.PublishReply) */ {
 public:
  inline PublishReply() : PublishReply(nullptr) {}
  ~PublishReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PublishReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PublishReply(const PublishReply& from);
  PublishReply(PublishReply&& from) noexcept
    : PublishReply() {
    *this = ::std::move(from);
  }

  inline PublishReply& operator=(const PublishReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublishReply& operator=(PublishReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PublishReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublishReply* internal_default_instance() {
    return reinterpret_cast<const PublishReply*>(
               &_PublishReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PublishReply& a, PublishReply& b) {
    a.Swap(&b);
  }
  inline void Swap(PublishReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublishReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PublishReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PublishReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PublishReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PublishReply& from) {
    PublishReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PublishReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "myserver.PublishReply";
  }
  protected:
  explicit PublishReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
  };
  // string response = 1;
  void clear_response() ;
  const std::string& response() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_response(Arg_&& arg, Args_... args);
  std::string* mutable_response();
  PROTOBUF_NODISCARD std::string* release_response();
  void set_allocated_response(std::string* ptr);

  private:
  const std::string& _internal_response() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_response(
      const std::string& value);
  std::string* _internal_mutable_response();

  public:
  // @@protoc_insertion_point(class_scope:myserver.PublishReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fmyServer_2eproto;
};// -------------------------------------------------------------------

class SubscribeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:myserver.SubscribeRequest) */ {
 public:
  inline SubscribeRequest() : SubscribeRequest(nullptr) {}
  ~SubscribeRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeRequest(const SubscribeRequest& from);
  SubscribeRequest(SubscribeRequest&& from) noexcept
    : SubscribeRequest() {
    *this = ::std::move(from);
  }

  inline SubscribeRequest& operator=(const SubscribeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeRequest& operator=(SubscribeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeRequest* internal_default_instance() {
    return reinterpret_cast<const SubscribeRequest*>(
               &_SubscribeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SubscribeRequest& a, SubscribeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscribeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubscribeRequest& from) {
    SubscribeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscribeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "myserver.SubscribeRequest";
  }
  protected:
  explicit SubscribeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdrsFieldNumber = 1,
    kTopicFieldNumber = 2,
    kClientIDFieldNumber = 3,
  };
  // string adrs = 1;
  void clear_adrs() ;
  const std::string& adrs() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_adrs(Arg_&& arg, Args_... args);
  std::string* mutable_adrs();
  PROTOBUF_NODISCARD std::string* release_adrs();
  void set_allocated_adrs(std::string* ptr);

  private:
  const std::string& _internal_adrs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_adrs(
      const std::string& value);
  std::string* _internal_mutable_adrs();

  public:
  // string topic = 2;
  void clear_topic() ;
  const std::string& topic() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_topic(Arg_&& arg, Args_... args);
  std::string* mutable_topic();
  PROTOBUF_NODISCARD std::string* release_topic();
  void set_allocated_topic(std::string* ptr);

  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(
      const std::string& value);
  std::string* _internal_mutable_topic();

  public:
  // string clientID = 3;
  void clear_clientid() ;
  const std::string& clientid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_clientid(Arg_&& arg, Args_... args);
  std::string* mutable_clientid();
  PROTOBUF_NODISCARD std::string* release_clientid();
  void set_allocated_clientid(std::string* ptr);

  private:
  const std::string& _internal_clientid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientid(
      const std::string& value);
  std::string* _internal_mutable_clientid();

  public:
  // @@protoc_insertion_point(class_scope:myserver.SubscribeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr adrs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fmyServer_2eproto;
};// -------------------------------------------------------------------

class SubscribeReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:myserver.SubscribeReply) */ {
 public:
  inline SubscribeReply() : SubscribeReply(nullptr) {}
  ~SubscribeReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribeReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeReply(const SubscribeReply& from);
  SubscribeReply(SubscribeReply&& from) noexcept
    : SubscribeReply() {
    *this = ::std::move(from);
  }

  inline SubscribeReply& operator=(const SubscribeReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeReply& operator=(SubscribeReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeReply* internal_default_instance() {
    return reinterpret_cast<const SubscribeReply*>(
               &_SubscribeReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SubscribeReply& a, SubscribeReply& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscribeReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubscribeReply& from) {
    SubscribeReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscribeReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "myserver.SubscribeReply";
  }
  protected:
  explicit SubscribeReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
  };
  // string response = 1;
  void clear_response() ;
  const std::string& response() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_response(Arg_&& arg, Args_... args);
  std::string* mutable_response();
  PROTOBUF_NODISCARD std::string* release_response();
  void set_allocated_response(std::string* ptr);

  private:
  const std::string& _internal_response() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_response(
      const std::string& value);
  std::string* _internal_mutable_response();

  public:
  // @@protoc_insertion_point(class_scope:myserver.SubscribeReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fmyServer_2eproto;
};// -------------------------------------------------------------------

class ShowBrokersRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:myserver.ShowBrokersRequest) */ {
 public:
  inline ShowBrokersRequest() : ShowBrokersRequest(nullptr) {}
  ~ShowBrokersRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ShowBrokersRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShowBrokersRequest(const ShowBrokersRequest& from);
  ShowBrokersRequest(ShowBrokersRequest&& from) noexcept
    : ShowBrokersRequest() {
    *this = ::std::move(from);
  }

  inline ShowBrokersRequest& operator=(const ShowBrokersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShowBrokersRequest& operator=(ShowBrokersRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShowBrokersRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShowBrokersRequest* internal_default_instance() {
    return reinterpret_cast<const ShowBrokersRequest*>(
               &_ShowBrokersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ShowBrokersRequest& a, ShowBrokersRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ShowBrokersRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShowBrokersRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShowBrokersRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShowBrokersRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShowBrokersRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShowBrokersRequest& from) {
    ShowBrokersRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShowBrokersRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "myserver.ShowBrokersRequest";
  }
  protected:
  explicit ShowBrokersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqFieldNumber = 1,
  };
  // string req = 1;
  void clear_req() ;
  const std::string& req() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_req(Arg_&& arg, Args_... args);
  std::string* mutable_req();
  PROTOBUF_NODISCARD std::string* release_req();
  void set_allocated_req(std::string* ptr);

  private:
  const std::string& _internal_req() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_req(
      const std::string& value);
  std::string* _internal_mutable_req();

  public:
  // @@protoc_insertion_point(class_scope:myserver.ShowBrokersRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr req_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fmyServer_2eproto;
};// -------------------------------------------------------------------

class ShowBrokersReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:myserver.ShowBrokersReply) */ {
 public:
  inline ShowBrokersReply() : ShowBrokersReply(nullptr) {}
  ~ShowBrokersReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ShowBrokersReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShowBrokersReply(const ShowBrokersReply& from);
  ShowBrokersReply(ShowBrokersReply&& from) noexcept
    : ShowBrokersReply() {
    *this = ::std::move(from);
  }

  inline ShowBrokersReply& operator=(const ShowBrokersReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShowBrokersReply& operator=(ShowBrokersReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShowBrokersReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShowBrokersReply* internal_default_instance() {
    return reinterpret_cast<const ShowBrokersReply*>(
               &_ShowBrokersReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ShowBrokersReply& a, ShowBrokersReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ShowBrokersReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShowBrokersReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShowBrokersReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShowBrokersReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShowBrokersReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShowBrokersReply& from) {
    ShowBrokersReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShowBrokersReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "myserver.ShowBrokersReply";
  }
  protected:
  explicit ShowBrokersReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
  };
  // string response = 1;
  void clear_response() ;
  const std::string& response() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_response(Arg_&& arg, Args_... args);
  std::string* mutable_response();
  PROTOBUF_NODISCARD std::string* release_response();
  void set_allocated_response(std::string* ptr);

  private:
  const std::string& _internal_response() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_response(
      const std::string& value);
  std::string* _internal_mutable_response();

  public:
  // @@protoc_insertion_point(class_scope:myserver.ShowBrokersReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fmyServer_2eproto;
};// -------------------------------------------------------------------

class ShowClientsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:myserver.ShowClientsRequest) */ {
 public:
  inline ShowClientsRequest() : ShowClientsRequest(nullptr) {}
  ~ShowClientsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ShowClientsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShowClientsRequest(const ShowClientsRequest& from);
  ShowClientsRequest(ShowClientsRequest&& from) noexcept
    : ShowClientsRequest() {
    *this = ::std::move(from);
  }

  inline ShowClientsRequest& operator=(const ShowClientsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShowClientsRequest& operator=(ShowClientsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShowClientsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShowClientsRequest* internal_default_instance() {
    return reinterpret_cast<const ShowClientsRequest*>(
               &_ShowClientsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ShowClientsRequest& a, ShowClientsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ShowClientsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShowClientsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShowClientsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShowClientsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShowClientsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShowClientsRequest& from) {
    ShowClientsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShowClientsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "myserver.ShowClientsRequest";
  }
  protected:
  explicit ShowClientsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqFieldNumber = 1,
  };
  // string req = 1;
  void clear_req() ;
  const std::string& req() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_req(Arg_&& arg, Args_... args);
  std::string* mutable_req();
  PROTOBUF_NODISCARD std::string* release_req();
  void set_allocated_req(std::string* ptr);

  private:
  const std::string& _internal_req() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_req(
      const std::string& value);
  std::string* _internal_mutable_req();

  public:
  // @@protoc_insertion_point(class_scope:myserver.ShowClientsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr req_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fmyServer_2eproto;
};// -------------------------------------------------------------------

class ShowClientsReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:myserver.ShowClientsReply) */ {
 public:
  inline ShowClientsReply() : ShowClientsReply(nullptr) {}
  ~ShowClientsReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ShowClientsReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShowClientsReply(const ShowClientsReply& from);
  ShowClientsReply(ShowClientsReply&& from) noexcept
    : ShowClientsReply() {
    *this = ::std::move(from);
  }

  inline ShowClientsReply& operator=(const ShowClientsReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShowClientsReply& operator=(ShowClientsReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShowClientsReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShowClientsReply* internal_default_instance() {
    return reinterpret_cast<const ShowClientsReply*>(
               &_ShowClientsReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ShowClientsReply& a, ShowClientsReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ShowClientsReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShowClientsReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShowClientsReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShowClientsReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShowClientsReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShowClientsReply& from) {
    ShowClientsReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShowClientsReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "myserver.ShowClientsReply";
  }
  protected:
  explicit ShowClientsReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
  };
  // string response = 1;
  void clear_response() ;
  const std::string& response() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_response(Arg_&& arg, Args_... args);
  std::string* mutable_response();
  PROTOBUF_NODISCARD std::string* release_response();
  void set_allocated_response(std::string* ptr);

  private:
  const std::string& _internal_response() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_response(
      const std::string& value);
  std::string* _internal_mutable_response();

  public:
  // @@protoc_insertion_point(class_scope:myserver.ShowClientsReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fmyServer_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// ConnectRequest

// string adrs = 1;
inline void ConnectRequest::clear_adrs() {
  _impl_.adrs_.ClearToEmpty();
}
inline const std::string& ConnectRequest::adrs() const {
  // @@protoc_insertion_point(field_get:myserver.ConnectRequest.adrs)
  return _internal_adrs();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ConnectRequest::set_adrs(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.adrs_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:myserver.ConnectRequest.adrs)
}
inline std::string* ConnectRequest::mutable_adrs() {
  std::string* _s = _internal_mutable_adrs();
  // @@protoc_insertion_point(field_mutable:myserver.ConnectRequest.adrs)
  return _s;
}
inline const std::string& ConnectRequest::_internal_adrs() const {
  return _impl_.adrs_.Get();
}
inline void ConnectRequest::_internal_set_adrs(const std::string& value) {
  ;


  _impl_.adrs_.Set(value, GetArenaForAllocation());
}
inline std::string* ConnectRequest::_internal_mutable_adrs() {
  ;
  return _impl_.adrs_.Mutable( GetArenaForAllocation());
}
inline std::string* ConnectRequest::release_adrs() {
  // @@protoc_insertion_point(field_release:myserver.ConnectRequest.adrs)
  return _impl_.adrs_.Release();
}
inline void ConnectRequest::set_allocated_adrs(std::string* value) {
  _impl_.adrs_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.adrs_.IsDefault()) {
          _impl_.adrs_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:myserver.ConnectRequest.adrs)
}

// string clientID = 2;
inline void ConnectRequest::clear_clientid() {
  _impl_.clientid_.ClearToEmpty();
}
inline const std::string& ConnectRequest::clientid() const {
  // @@protoc_insertion_point(field_get:myserver.ConnectRequest.clientID)
  return _internal_clientid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ConnectRequest::set_clientid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.clientid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:myserver.ConnectRequest.clientID)
}
inline std::string* ConnectRequest::mutable_clientid() {
  std::string* _s = _internal_mutable_clientid();
  // @@protoc_insertion_point(field_mutable:myserver.ConnectRequest.clientID)
  return _s;
}
inline const std::string& ConnectRequest::_internal_clientid() const {
  return _impl_.clientid_.Get();
}
inline void ConnectRequest::_internal_set_clientid(const std::string& value) {
  ;


  _impl_.clientid_.Set(value, GetArenaForAllocation());
}
inline std::string* ConnectRequest::_internal_mutable_clientid() {
  ;
  return _impl_.clientid_.Mutable( GetArenaForAllocation());
}
inline std::string* ConnectRequest::release_clientid() {
  // @@protoc_insertion_point(field_release:myserver.ConnectRequest.clientID)
  return _impl_.clientid_.Release();
}
inline void ConnectRequest::set_allocated_clientid(std::string* value) {
  _impl_.clientid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.clientid_.IsDefault()) {
          _impl_.clientid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:myserver.ConnectRequest.clientID)
}

// -------------------------------------------------------------------

// ConnectReply

// string response = 1;
inline void ConnectReply::clear_response() {
  _impl_.response_.ClearToEmpty();
}
inline const std::string& ConnectReply::response() const {
  // @@protoc_insertion_point(field_get:myserver.ConnectReply.response)
  return _internal_response();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ConnectReply::set_response(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.response_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:myserver.ConnectReply.response)
}
inline std::string* ConnectReply::mutable_response() {
  std::string* _s = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:myserver.ConnectReply.response)
  return _s;
}
inline const std::string& ConnectReply::_internal_response() const {
  return _impl_.response_.Get();
}
inline void ConnectReply::_internal_set_response(const std::string& value) {
  ;


  _impl_.response_.Set(value, GetArenaForAllocation());
}
inline std::string* ConnectReply::_internal_mutable_response() {
  ;
  return _impl_.response_.Mutable( GetArenaForAllocation());
}
inline std::string* ConnectReply::release_response() {
  // @@protoc_insertion_point(field_release:myserver.ConnectReply.response)
  return _impl_.response_.Release();
}
inline void ConnectReply::set_allocated_response(std::string* value) {
  _impl_.response_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.response_.IsDefault()) {
          _impl_.response_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:myserver.ConnectReply.response)
}

// -------------------------------------------------------------------

// DisconnectRequest

// string adrs = 1;
inline void DisconnectRequest::clear_adrs() {
  _impl_.adrs_.ClearToEmpty();
}
inline const std::string& DisconnectRequest::adrs() const {
  // @@protoc_insertion_point(field_get:myserver.DisconnectRequest.adrs)
  return _internal_adrs();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DisconnectRequest::set_adrs(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.adrs_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:myserver.DisconnectRequest.adrs)
}
inline std::string* DisconnectRequest::mutable_adrs() {
  std::string* _s = _internal_mutable_adrs();
  // @@protoc_insertion_point(field_mutable:myserver.DisconnectRequest.adrs)
  return _s;
}
inline const std::string& DisconnectRequest::_internal_adrs() const {
  return _impl_.adrs_.Get();
}
inline void DisconnectRequest::_internal_set_adrs(const std::string& value) {
  ;


  _impl_.adrs_.Set(value, GetArenaForAllocation());
}
inline std::string* DisconnectRequest::_internal_mutable_adrs() {
  ;
  return _impl_.adrs_.Mutable( GetArenaForAllocation());
}
inline std::string* DisconnectRequest::release_adrs() {
  // @@protoc_insertion_point(field_release:myserver.DisconnectRequest.adrs)
  return _impl_.adrs_.Release();
}
inline void DisconnectRequest::set_allocated_adrs(std::string* value) {
  _impl_.adrs_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.adrs_.IsDefault()) {
          _impl_.adrs_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:myserver.DisconnectRequest.adrs)
}

// string clientID = 2;
inline void DisconnectRequest::clear_clientid() {
  _impl_.clientid_.ClearToEmpty();
}
inline const std::string& DisconnectRequest::clientid() const {
  // @@protoc_insertion_point(field_get:myserver.DisconnectRequest.clientID)
  return _internal_clientid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DisconnectRequest::set_clientid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.clientid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:myserver.DisconnectRequest.clientID)
}
inline std::string* DisconnectRequest::mutable_clientid() {
  std::string* _s = _internal_mutable_clientid();
  // @@protoc_insertion_point(field_mutable:myserver.DisconnectRequest.clientID)
  return _s;
}
inline const std::string& DisconnectRequest::_internal_clientid() const {
  return _impl_.clientid_.Get();
}
inline void DisconnectRequest::_internal_set_clientid(const std::string& value) {
  ;


  _impl_.clientid_.Set(value, GetArenaForAllocation());
}
inline std::string* DisconnectRequest::_internal_mutable_clientid() {
  ;
  return _impl_.clientid_.Mutable( GetArenaForAllocation());
}
inline std::string* DisconnectRequest::release_clientid() {
  // @@protoc_insertion_point(field_release:myserver.DisconnectRequest.clientID)
  return _impl_.clientid_.Release();
}
inline void DisconnectRequest::set_allocated_clientid(std::string* value) {
  _impl_.clientid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.clientid_.IsDefault()) {
          _impl_.clientid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:myserver.DisconnectRequest.clientID)
}

// -------------------------------------------------------------------

// DisconnectReply

// string response = 1;
inline void DisconnectReply::clear_response() {
  _impl_.response_.ClearToEmpty();
}
inline const std::string& DisconnectReply::response() const {
  // @@protoc_insertion_point(field_get:myserver.DisconnectReply.response)
  return _internal_response();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DisconnectReply::set_response(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.response_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:myserver.DisconnectReply.response)
}
inline std::string* DisconnectReply::mutable_response() {
  std::string* _s = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:myserver.DisconnectReply.response)
  return _s;
}
inline const std::string& DisconnectReply::_internal_response() const {
  return _impl_.response_.Get();
}
inline void DisconnectReply::_internal_set_response(const std::string& value) {
  ;


  _impl_.response_.Set(value, GetArenaForAllocation());
}
inline std::string* DisconnectReply::_internal_mutable_response() {
  ;
  return _impl_.response_.Mutable( GetArenaForAllocation());
}
inline std::string* DisconnectReply::release_response() {
  // @@protoc_insertion_point(field_release:myserver.DisconnectReply.response)
  return _impl_.response_.Release();
}
inline void DisconnectReply::set_allocated_response(std::string* value) {
  _impl_.response_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.response_.IsDefault()) {
          _impl_.response_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:myserver.DisconnectReply.response)
}

// -------------------------------------------------------------------

// PublishRequest

// string adrs = 1;
inline void PublishRequest::clear_adrs() {
  _impl_.adrs_.ClearToEmpty();
}
inline const std::string& PublishRequest::adrs() const {
  // @@protoc_insertion_point(field_get:myserver.PublishRequest.adrs)
  return _internal_adrs();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PublishRequest::set_adrs(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.adrs_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:myserver.PublishRequest.adrs)
}
inline std::string* PublishRequest::mutable_adrs() {
  std::string* _s = _internal_mutable_adrs();
  // @@protoc_insertion_point(field_mutable:myserver.PublishRequest.adrs)
  return _s;
}
inline const std::string& PublishRequest::_internal_adrs() const {
  return _impl_.adrs_.Get();
}
inline void PublishRequest::_internal_set_adrs(const std::string& value) {
  ;


  _impl_.adrs_.Set(value, GetArenaForAllocation());
}
inline std::string* PublishRequest::_internal_mutable_adrs() {
  ;
  return _impl_.adrs_.Mutable( GetArenaForAllocation());
}
inline std::string* PublishRequest::release_adrs() {
  // @@protoc_insertion_point(field_release:myserver.PublishRequest.adrs)
  return _impl_.adrs_.Release();
}
inline void PublishRequest::set_allocated_adrs(std::string* value) {
  _impl_.adrs_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.adrs_.IsDefault()) {
          _impl_.adrs_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:myserver.PublishRequest.adrs)
}

// string topic = 2;
inline void PublishRequest::clear_topic() {
  _impl_.topic_.ClearToEmpty();
}
inline const std::string& PublishRequest::topic() const {
  // @@protoc_insertion_point(field_get:myserver.PublishRequest.topic)
  return _internal_topic();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PublishRequest::set_topic(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.topic_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:myserver.PublishRequest.topic)
}
inline std::string* PublishRequest::mutable_topic() {
  std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:myserver.PublishRequest.topic)
  return _s;
}
inline const std::string& PublishRequest::_internal_topic() const {
  return _impl_.topic_.Get();
}
inline void PublishRequest::_internal_set_topic(const std::string& value) {
  ;


  _impl_.topic_.Set(value, GetArenaForAllocation());
}
inline std::string* PublishRequest::_internal_mutable_topic() {
  ;
  return _impl_.topic_.Mutable( GetArenaForAllocation());
}
inline std::string* PublishRequest::release_topic() {
  // @@protoc_insertion_point(field_release:myserver.PublishRequest.topic)
  return _impl_.topic_.Release();
}
inline void PublishRequest::set_allocated_topic(std::string* value) {
  _impl_.topic_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.topic_.IsDefault()) {
          _impl_.topic_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:myserver.PublishRequest.topic)
}

// string message = 3;
inline void PublishRequest::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& PublishRequest::message() const {
  // @@protoc_insertion_point(field_get:myserver.PublishRequest.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PublishRequest::set_message(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:myserver.PublishRequest.message)
}
inline std::string* PublishRequest::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:myserver.PublishRequest.message)
  return _s;
}
inline const std::string& PublishRequest::_internal_message() const {
  return _impl_.message_.Get();
}
inline void PublishRequest::_internal_set_message(const std::string& value) {
  ;


  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* PublishRequest::_internal_mutable_message() {
  ;
  return _impl_.message_.Mutable( GetArenaForAllocation());
}
inline std::string* PublishRequest::release_message() {
  // @@protoc_insertion_point(field_release:myserver.PublishRequest.message)
  return _impl_.message_.Release();
}
inline void PublishRequest::set_allocated_message(std::string* value) {
  _impl_.message_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:myserver.PublishRequest.message)
}

// string clientID = 4;
inline void PublishRequest::clear_clientid() {
  _impl_.clientid_.ClearToEmpty();
}
inline const std::string& PublishRequest::clientid() const {
  // @@protoc_insertion_point(field_get:myserver.PublishRequest.clientID)
  return _internal_clientid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PublishRequest::set_clientid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.clientid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:myserver.PublishRequest.clientID)
}
inline std::string* PublishRequest::mutable_clientid() {
  std::string* _s = _internal_mutable_clientid();
  // @@protoc_insertion_point(field_mutable:myserver.PublishRequest.clientID)
  return _s;
}
inline const std::string& PublishRequest::_internal_clientid() const {
  return _impl_.clientid_.Get();
}
inline void PublishRequest::_internal_set_clientid(const std::string& value) {
  ;


  _impl_.clientid_.Set(value, GetArenaForAllocation());
}
inline std::string* PublishRequest::_internal_mutable_clientid() {
  ;
  return _impl_.clientid_.Mutable( GetArenaForAllocation());
}
inline std::string* PublishRequest::release_clientid() {
  // @@protoc_insertion_point(field_release:myserver.PublishRequest.clientID)
  return _impl_.clientid_.Release();
}
inline void PublishRequest::set_allocated_clientid(std::string* value) {
  _impl_.clientid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.clientid_.IsDefault()) {
          _impl_.clientid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:myserver.PublishRequest.clientID)
}

// -------------------------------------------------------------------

// PublishReply

// string response = 1;
inline void PublishReply::clear_response() {
  _impl_.response_.ClearToEmpty();
}
inline const std::string& PublishReply::response() const {
  // @@protoc_insertion_point(field_get:myserver.PublishReply.response)
  return _internal_response();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PublishReply::set_response(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.response_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:myserver.PublishReply.response)
}
inline std::string* PublishReply::mutable_response() {
  std::string* _s = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:myserver.PublishReply.response)
  return _s;
}
inline const std::string& PublishReply::_internal_response() const {
  return _impl_.response_.Get();
}
inline void PublishReply::_internal_set_response(const std::string& value) {
  ;


  _impl_.response_.Set(value, GetArenaForAllocation());
}
inline std::string* PublishReply::_internal_mutable_response() {
  ;
  return _impl_.response_.Mutable( GetArenaForAllocation());
}
inline std::string* PublishReply::release_response() {
  // @@protoc_insertion_point(field_release:myserver.PublishReply.response)
  return _impl_.response_.Release();
}
inline void PublishReply::set_allocated_response(std::string* value) {
  _impl_.response_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.response_.IsDefault()) {
          _impl_.response_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:myserver.PublishReply.response)
}

// -------------------------------------------------------------------

// SubscribeRequest

// string adrs = 1;
inline void SubscribeRequest::clear_adrs() {
  _impl_.adrs_.ClearToEmpty();
}
inline const std::string& SubscribeRequest::adrs() const {
  // @@protoc_insertion_point(field_get:myserver.SubscribeRequest.adrs)
  return _internal_adrs();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubscribeRequest::set_adrs(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.adrs_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:myserver.SubscribeRequest.adrs)
}
inline std::string* SubscribeRequest::mutable_adrs() {
  std::string* _s = _internal_mutable_adrs();
  // @@protoc_insertion_point(field_mutable:myserver.SubscribeRequest.adrs)
  return _s;
}
inline const std::string& SubscribeRequest::_internal_adrs() const {
  return _impl_.adrs_.Get();
}
inline void SubscribeRequest::_internal_set_adrs(const std::string& value) {
  ;


  _impl_.adrs_.Set(value, GetArenaForAllocation());
}
inline std::string* SubscribeRequest::_internal_mutable_adrs() {
  ;
  return _impl_.adrs_.Mutable( GetArenaForAllocation());
}
inline std::string* SubscribeRequest::release_adrs() {
  // @@protoc_insertion_point(field_release:myserver.SubscribeRequest.adrs)
  return _impl_.adrs_.Release();
}
inline void SubscribeRequest::set_allocated_adrs(std::string* value) {
  _impl_.adrs_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.adrs_.IsDefault()) {
          _impl_.adrs_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:myserver.SubscribeRequest.adrs)
}

// string topic = 2;
inline void SubscribeRequest::clear_topic() {
  _impl_.topic_.ClearToEmpty();
}
inline const std::string& SubscribeRequest::topic() const {
  // @@protoc_insertion_point(field_get:myserver.SubscribeRequest.topic)
  return _internal_topic();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubscribeRequest::set_topic(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.topic_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:myserver.SubscribeRequest.topic)
}
inline std::string* SubscribeRequest::mutable_topic() {
  std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:myserver.SubscribeRequest.topic)
  return _s;
}
inline const std::string& SubscribeRequest::_internal_topic() const {
  return _impl_.topic_.Get();
}
inline void SubscribeRequest::_internal_set_topic(const std::string& value) {
  ;


  _impl_.topic_.Set(value, GetArenaForAllocation());
}
inline std::string* SubscribeRequest::_internal_mutable_topic() {
  ;
  return _impl_.topic_.Mutable( GetArenaForAllocation());
}
inline std::string* SubscribeRequest::release_topic() {
  // @@protoc_insertion_point(field_release:myserver.SubscribeRequest.topic)
  return _impl_.topic_.Release();
}
inline void SubscribeRequest::set_allocated_topic(std::string* value) {
  _impl_.topic_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.topic_.IsDefault()) {
          _impl_.topic_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:myserver.SubscribeRequest.topic)
}

// string clientID = 3;
inline void SubscribeRequest::clear_clientid() {
  _impl_.clientid_.ClearToEmpty();
}
inline const std::string& SubscribeRequest::clientid() const {
  // @@protoc_insertion_point(field_get:myserver.SubscribeRequest.clientID)
  return _internal_clientid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubscribeRequest::set_clientid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.clientid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:myserver.SubscribeRequest.clientID)
}
inline std::string* SubscribeRequest::mutable_clientid() {
  std::string* _s = _internal_mutable_clientid();
  // @@protoc_insertion_point(field_mutable:myserver.SubscribeRequest.clientID)
  return _s;
}
inline const std::string& SubscribeRequest::_internal_clientid() const {
  return _impl_.clientid_.Get();
}
inline void SubscribeRequest::_internal_set_clientid(const std::string& value) {
  ;


  _impl_.clientid_.Set(value, GetArenaForAllocation());
}
inline std::string* SubscribeRequest::_internal_mutable_clientid() {
  ;
  return _impl_.clientid_.Mutable( GetArenaForAllocation());
}
inline std::string* SubscribeRequest::release_clientid() {
  // @@protoc_insertion_point(field_release:myserver.SubscribeRequest.clientID)
  return _impl_.clientid_.Release();
}
inline void SubscribeRequest::set_allocated_clientid(std::string* value) {
  _impl_.clientid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.clientid_.IsDefault()) {
          _impl_.clientid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:myserver.SubscribeRequest.clientID)
}

// -------------------------------------------------------------------

// SubscribeReply

// string response = 1;
inline void SubscribeReply::clear_response() {
  _impl_.response_.ClearToEmpty();
}
inline const std::string& SubscribeReply::response() const {
  // @@protoc_insertion_point(field_get:myserver.SubscribeReply.response)
  return _internal_response();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubscribeReply::set_response(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.response_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:myserver.SubscribeReply.response)
}
inline std::string* SubscribeReply::mutable_response() {
  std::string* _s = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:myserver.SubscribeReply.response)
  return _s;
}
inline const std::string& SubscribeReply::_internal_response() const {
  return _impl_.response_.Get();
}
inline void SubscribeReply::_internal_set_response(const std::string& value) {
  ;


  _impl_.response_.Set(value, GetArenaForAllocation());
}
inline std::string* SubscribeReply::_internal_mutable_response() {
  ;
  return _impl_.response_.Mutable( GetArenaForAllocation());
}
inline std::string* SubscribeReply::release_response() {
  // @@protoc_insertion_point(field_release:myserver.SubscribeReply.response)
  return _impl_.response_.Release();
}
inline void SubscribeReply::set_allocated_response(std::string* value) {
  _impl_.response_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.response_.IsDefault()) {
          _impl_.response_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:myserver.SubscribeReply.response)
}

// -------------------------------------------------------------------

// ShowBrokersRequest

// string req = 1;
inline void ShowBrokersRequest::clear_req() {
  _impl_.req_.ClearToEmpty();
}
inline const std::string& ShowBrokersRequest::req() const {
  // @@protoc_insertion_point(field_get:myserver.ShowBrokersRequest.req)
  return _internal_req();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ShowBrokersRequest::set_req(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.req_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:myserver.ShowBrokersRequest.req)
}
inline std::string* ShowBrokersRequest::mutable_req() {
  std::string* _s = _internal_mutable_req();
  // @@protoc_insertion_point(field_mutable:myserver.ShowBrokersRequest.req)
  return _s;
}
inline const std::string& ShowBrokersRequest::_internal_req() const {
  return _impl_.req_.Get();
}
inline void ShowBrokersRequest::_internal_set_req(const std::string& value) {
  ;


  _impl_.req_.Set(value, GetArenaForAllocation());
}
inline std::string* ShowBrokersRequest::_internal_mutable_req() {
  ;
  return _impl_.req_.Mutable( GetArenaForAllocation());
}
inline std::string* ShowBrokersRequest::release_req() {
  // @@protoc_insertion_point(field_release:myserver.ShowBrokersRequest.req)
  return _impl_.req_.Release();
}
inline void ShowBrokersRequest::set_allocated_req(std::string* value) {
  _impl_.req_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.req_.IsDefault()) {
          _impl_.req_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:myserver.ShowBrokersRequest.req)
}

// -------------------------------------------------------------------

// ShowBrokersReply

// string response = 1;
inline void ShowBrokersReply::clear_response() {
  _impl_.response_.ClearToEmpty();
}
inline const std::string& ShowBrokersReply::response() const {
  // @@protoc_insertion_point(field_get:myserver.ShowBrokersReply.response)
  return _internal_response();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ShowBrokersReply::set_response(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.response_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:myserver.ShowBrokersReply.response)
}
inline std::string* ShowBrokersReply::mutable_response() {
  std::string* _s = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:myserver.ShowBrokersReply.response)
  return _s;
}
inline const std::string& ShowBrokersReply::_internal_response() const {
  return _impl_.response_.Get();
}
inline void ShowBrokersReply::_internal_set_response(const std::string& value) {
  ;


  _impl_.response_.Set(value, GetArenaForAllocation());
}
inline std::string* ShowBrokersReply::_internal_mutable_response() {
  ;
  return _impl_.response_.Mutable( GetArenaForAllocation());
}
inline std::string* ShowBrokersReply::release_response() {
  // @@protoc_insertion_point(field_release:myserver.ShowBrokersReply.response)
  return _impl_.response_.Release();
}
inline void ShowBrokersReply::set_allocated_response(std::string* value) {
  _impl_.response_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.response_.IsDefault()) {
          _impl_.response_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:myserver.ShowBrokersReply.response)
}

// -------------------------------------------------------------------

// ShowClientsRequest

// string req = 1;
inline void ShowClientsRequest::clear_req() {
  _impl_.req_.ClearToEmpty();
}
inline const std::string& ShowClientsRequest::req() const {
  // @@protoc_insertion_point(field_get:myserver.ShowClientsRequest.req)
  return _internal_req();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ShowClientsRequest::set_req(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.req_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:myserver.ShowClientsRequest.req)
}
inline std::string* ShowClientsRequest::mutable_req() {
  std::string* _s = _internal_mutable_req();
  // @@protoc_insertion_point(field_mutable:myserver.ShowClientsRequest.req)
  return _s;
}
inline const std::string& ShowClientsRequest::_internal_req() const {
  return _impl_.req_.Get();
}
inline void ShowClientsRequest::_internal_set_req(const std::string& value) {
  ;


  _impl_.req_.Set(value, GetArenaForAllocation());
}
inline std::string* ShowClientsRequest::_internal_mutable_req() {
  ;
  return _impl_.req_.Mutable( GetArenaForAllocation());
}
inline std::string* ShowClientsRequest::release_req() {
  // @@protoc_insertion_point(field_release:myserver.ShowClientsRequest.req)
  return _impl_.req_.Release();
}
inline void ShowClientsRequest::set_allocated_req(std::string* value) {
  _impl_.req_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.req_.IsDefault()) {
          _impl_.req_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:myserver.ShowClientsRequest.req)
}

// -------------------------------------------------------------------

// ShowClientsReply

// string response = 1;
inline void ShowClientsReply::clear_response() {
  _impl_.response_.ClearToEmpty();
}
inline const std::string& ShowClientsReply::response() const {
  // @@protoc_insertion_point(field_get:myserver.ShowClientsReply.response)
  return _internal_response();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ShowClientsReply::set_response(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.response_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:myserver.ShowClientsReply.response)
}
inline std::string* ShowClientsReply::mutable_response() {
  std::string* _s = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:myserver.ShowClientsReply.response)
  return _s;
}
inline const std::string& ShowClientsReply::_internal_response() const {
  return _impl_.response_.Get();
}
inline void ShowClientsReply::_internal_set_response(const std::string& value) {
  ;


  _impl_.response_.Set(value, GetArenaForAllocation());
}
inline std::string* ShowClientsReply::_internal_mutable_response() {
  ;
  return _impl_.response_.Mutable( GetArenaForAllocation());
}
inline std::string* ShowClientsReply::release_response() {
  // @@protoc_insertion_point(field_release:myserver.ShowClientsReply.response)
  return _impl_.response_.Release();
}
inline void ShowClientsReply::set_allocated_response(std::string* value) {
  _impl_.response_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.response_.IsDefault()) {
          _impl_.response_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:myserver.ShowClientsReply.response)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace myserver


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_protos_2fmyServer_2eproto_2epb_2eh
